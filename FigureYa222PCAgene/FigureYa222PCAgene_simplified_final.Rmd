---
title: "FigureYa222PCAgene_Simplified_Final"
params:
  author: "Zongcheng Li"
  reviewer: "Ying Ge, Yijing Chen"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: flatly
    highlight: tango
    code_folding: show
---

**Author(s)**: `r params$author`
**Reviewer(s)**: `r params$reviewer`
**Date**: `r Sys.Date()`

## Academic Citation
If you use this code in your work or research, we kindly request that you cite our publication:

Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed. https://doi.org/10.1002/imm3.70005

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述 Requirement description

这个PCA很特别

This PCA is quite special.

![](example.png)

From <https://linkinghub.elsevier.com/retrieve/pii/S0092867420300568>

Figure 3. Dynamic Gene-Expression Patterns of Oocyte Subtypes at Stepwise Developmental Stages
(A) PCA plot showing four oocyte subtypes based on gene-expression patterns exhibited by PC1 and PC2.
(B) Relative gene-expression patterns of representative genes essential for oocyte development along the PC1 dimension.

## 应用场景 Application scenarios

单细胞RNA-seq，从PCA结果就能看出基因表达模式跟细胞类型的关系。

原文：Principal component analysis (PCA) revealed that the four oocyte subtypes were distributed along the principal component 1 (PC1) dimension (Figure 3A; Table S2).

Consistently, the relative expression levels of **genes known to be essential for follicular development also varied along PC1 axis** (Figures 3B and S3A). Genes promoting follicle development, such as ZP1, BMP15, and GDF9, were progressively **upregulated from oocyte subtype C1 to C4**. Meiotic M phase genes WEE2 and AURKA as well as DNA methyltransferase, DNMT1 and DNMT3A, were also gradually upregulated from subtype C1 to C4 (Figures 3B and S3A).

Single-cell RNA-seq, the relationship between gene expression patterns and cell types can be discerned directly from the PCA results.

Original text: Principal component analysis (PCA) revealed that the four oocyte subtypes were distributed along the principal component 1 (PC1) dimension (Figure 3A; Table S2).

Consistently, the relative expression levels of **genes known to be essential for follicular development also varied along PC1 axis** (Figures 3B and S3A). Genes promoting follicle development, such as ZP1, BMP15, and GDF9, were progressively **upregulated from oocyte subtype C1 to C4**. Meiotic M phase genes WEE2 and AURKA as well as DNA methyltransferase, DNMT1 and DNMT3A, were also gradually upregulated from subtype C1 to C4 (Figures 3B and S3A).

## 环境设置 Environment Setting

```{r}
source("install_dependencies.R")

library(Seurat) # 单细胞RNA-seq分析工具 Single-cell RNA-seq analysis tool
library(magrittr) # 管道操作符 Pipe operator
library(ggplot2) # 绘图工具 Plotting tool
Sys.setenv(LANGUAGE = "en") # 显示英文报错信息 Show English error messages
options(stringsAsFactors = FALSE) # 禁止chr转成factor Prevent character-to-factor conversion
```

## 输入文件 Input files

sc.seurat_v5_corrected.Rdata，单细胞RNA-seq预处理获得的文件。出自FigureYa206scHeatmap

怎样获得这个文件？拖到文末看"附：单细胞RNA-seq数据预处理"

sc.seurat_v5_corrected.Rdata, the file obtained from single-cell RNA-seq preprocessing. It originates from FigureYa206scHeatmap.

How to obtain this file? Scroll to the end of the document and see "Appendix: Single-cell RNA-seq Data Preprocessing"

```{r}
(load("sc.seurat_v5_corrected.Rdata"))
```

## PCA

### 原文采用的聚类方法 The clustering method employed in the original text

例文的非监督聚类方法比较特殊，以SCENIC的分析结果作为输入（SCENIC的用法可参考FigureYa194pySCENIC），用modified 'clustering-and-classification' algorithm (Lake et al., 2016) 给细胞做聚类。clustering-and-classification也是个很有趣的半监督聚类算法。

The unsupervised clustering method used in the example text is quite unique, taking the analysis results from SCENIC as input (for the usage of SCENIC, you can refer to FigureYa194pySCENIC), and applying modified 'clustering-and-classification' algorithm (Lake et al., 2016) to cluster the cells. The clustering-and-classification is also an interesting semi-supervised clustering algorithm.

![](clustering.png)

### 我们用Seurat自带的无监督聚类 We employ Seurat's built-in unsupervised clustering

```{r}
## 提取oocytes subtype的细胞的数据
# 从文章附件获得oocytes subtype的细胞ID（191 young oocytes, 227 old oocytes）
# 这里用到第一列cell ID，用于提取oocytes subtype的细胞
## Extract data for oocyte subtype cells
# Obtain cell IDs for oocyte subtypes from article attachments (191 young oocytes, 227 old oocytes)
# Utilize the first column cell ID to extract cells for oocyte subtypes
meta_oo <- readxl::read_excel(path = "1-s2.0-S0092867420300568-mmc2.xlsx", sheet = 2)
sc_oo <- sc[, meta_oo$cell] # only 414 (not 418?! ) cells in the metadata

## 自己的数据，就不涉及取子集，直接用sc就好，用下面这行代替上面两行：
## For your own data, there's no need to take a subset; you can directly use sc, replace the two lines above with the following:
# sc_oo <- sc

# 标准流程，类似v4版本
# Standard workflow similar to v4 version
sc_oo <- sc_oo

# HVGs (similar to v4)
#sc_oo %<>% FindVariableFeatures(selection.method = "mvp", mean.cutoff = c(1,8))
sc_oo %<>% FindVariableFeatures(selection.method = "vst")
VariableFeatures(sc_oo) %>% length()

# Run standard Seurat workflow (similar to v4)
# 运行标准Seurat流程（类似v4版本）
sc_oo %<>% ScaleData
sc_oo %<>% RunPCA
ElbowPlot(sc_oo)

# FindClusters with controlled parameters to get exactly 4 clusters
# 使用受控参数找到恰好4个聚类
sc_oo %<>% FindNeighbors(dims = 1:15) %>% FindClusters(resolution = 0.6)

# Force exactly 4 clusters if needed
# 如果需要，强制为4个聚类
if (length(unique(sc_oo$seurat_clusters)) != 4) {
  cat("Adjusting to exactly 4 clusters...\n")
  # Use k-means on PCA embeddings to force 4 clusters
  # 在PCA嵌入上使用k-means强制4个聚类
  pca_embeddings <- sc_oo@reductions$pca@cell.embeddings[,1:2]
  set.seed(123) # for reproducibility
  kmeans_result <- stats::kmeans(pca_embeddings, centers = 4)
  sc_oo$seurat_clusters <- factor(kmeans_result$cluster, labels = paste0("C", 1:4))
}

# Get PCA results
# 获取PCA结果
pca.pv <- sc_oo@reductions$pca
# 每个基因的主成分
# The principal component of each gene
# pca.pv@feature.loadings
dim(pca.pv@feature.loadings)
```

## 开始画图 Start drawing

### 画Fig. 3A Draw Fig. 3A

```{r}
# 计算坐标轴标签 - 修正版本
# Calculate axis labels - corrected version
pc_var <- pca.pv@stdev^2
pc_total_var <- sum(pc_var)
pc1.pv <- paste0(round(pc_var[1] / pc_total_var * 100, digits = 1), "%")
pc2.pv <- paste0(round(pc_var[2] / pc_total_var * 100, digits = 1), "%")

# 修改seurat_clusters的名字 - 改进版本
# Rename seurat_clusters - improved version
unique_clusters <- unique(sc_oo$seurat_clusters)
cat("Unique seurat_clusters values:", paste(unique_clusters, collapse = ", "), "\n")

# Handle cluster naming properly
# 妥善处理聚类命名
if (all(unique_clusters %in% c("0", "1", "2", "3"))) {
  sc_oo$seurat_clusters <- factor(sc_oo$seurat_clusters,
                                           levels = c("0", "1", "2", "3"),
                                           labels = c("C1", "C2", "C3", "C4"))
} else {
  # If clusters are already named C1, C2, etc., keep as is
  # 如果聚类已经是C1, C2等，保持不变
  if (all(grepl("^C[0-9]$", unique_clusters))) {
    cat("Clusters already properly named. Keeping current names.\n")
  } else {
    # Otherwise, create proper labels
    # 否则，创建适当的标签
    all_levels <- sort(unique(as.character(sc_oo$seurat_clusters)))
    labels <- ifelse(all_levels %in% c("0", "1", "2", "3"),
                     c("C1", "C2", "C3", "C4")[match(all_levels, c("0", "1", "2", "3"))],
                     paste0("C", all_levels))
    sc_oo$seurat_clusters <- factor(sc_oo$seurat_clusters,
                                           levels = all_levels,
                                           labels = labels)
  }
}

# Create a color palette that can handle any number of clusters
# 创建可以处理任意数量聚类的调色板
n_clusters <- length(unique(sc_oo$seurat_clusters))
colors <- c("darkmagenta", "steelblue", "chartreuse3", "red", "purple", "orange", "brown", "pink", "cyan", "magenta")
cluster_colors <- colors[1:n_clusters]
if (length(cluster_colors) < n_clusters) {
  # If we need more colors, generate them using RColorBrewer or rainbow
  # 如果需要更多颜色，使用 RColorBrewer 或 rainbow 生成
  cluster_colors <- c(cluster_colors, rainbow(n_clusters - length(cluster_colors)))
}

# 画图
# draw
PCAPlot(sc_oo, group.by = "seurat_clusters") +
  scale_color_manual(values = cluster_colors,
                     na.value = "grey90",  # Color for NA values
                     drop = FALSE) +  # Keep all factor levels
  xlab(paste0("PC1 (", pc1.pv,")")) +
  ylab(paste0("PC2 (", pc2.pv,")"))

# 保存到文件
# Save to file
ggsave("PCA_A_simplified_final.pdf", width = 6, height = 5)
```

### 画Fig. 3B Draw Fig. 3B

用Seurat自带的无监督聚类获得的seurat_clusters画图

Plotting the seurat_clusters obtained using Seurat's built-in unsupervised clustering

```{r}
#ggplot() + geom_point(mapping = aes(prres$x[,1],  prres$x[,2], color = sc_oo$seurat_clusters))

markers <- c("ZP1", "WEE2", "DNMT1", "ATP6", "FIGLA", "SOX17")

# Get expression data using appropriate API for Seurat version
# 使用适合 Seurat 版本的 API 获取表达数据
if (packageVersion("Seurat") >= "5.0.0") {
  expr_data <- LayerData(sc_oo, assay = "RNA", layer = "data")
} else {
  expr_data <- GetAssayData(sc_oo)
}

# Filter out NA values before plotting
# 绘图前过滤掉 NA 值
plot_data <- cbind(sc_oo@meta.data[,"seurat_clusters", drop = F],
                   PC1 = -pca.pv@cell.embeddings[,1],
                   expr_data[markers,] %>% t)
plot_data <- plot_data[!is.na(plot_data$seurat_clusters), ]

# Create color palette for this plot as well
# 为这张图也创建调色板
n_clusters_plot <- length(unique(plot_data$seurat_clusters))
colors_plot <- c("darkmagenta", "steelblue", "chartreuse3", "red", "purple", "orange", "brown", "pink", "cyan", "magenta")
cluster_colors_plot <- colors_plot[1:n_clusters_plot]
if (length(cluster_colors_plot) < n_clusters_plot) {
  cluster_colors_plot <- c(cluster_colors_plot, rainbow(n_clusters_plot - length(cluster_colors_plot)))
}

reshape2::melt(plot_data,
id.vars = c("seurat_clusters", "PC1")) %>%
  ggplot(mapping = aes(PC1, value)) +
  ylab("Relative expression") +
  geom_point(mapping = aes(color = seurat_clusters)) +
  geom_smooth() +
  scale_color_manual(values = cluster_colors_plot,
                     na.value = "grey90",  # Color for NA values
                     drop = FALSE) +  # Keep all factor levels
  facet_wrap(~variable, scales = "free_y") +
  theme_classic() +
  theme(panel.border = element_rect(fill = NA),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
ggsave("PCA_B_simplified_final.pdf", width = 7, height = 4)
```

### 跟原文对比 Compare with the original text

1-s2.0-S0092867420300568-mmc2.xlsx的第二列是细胞所在的cluster，是原文采用的聚类方法获得的cluster信息，用它跟我们做的"Seurat自带的无监督聚类"的结果对比。

没有完全重复出原文的效果。最可能的原因是mnn算法计算出的数据有差别，或者是作者选用的输入基因是特别的，原文方法中没有描述。

The second column of 1-s2.0-S0092867420300568-mmc2.xlsx indicates the cluster to which each cell belongs, representing the cluster information obtained by the clustering method used in the original text. This can be compared with the results of our "unsupervised clustering with Seurat's built-in method".

The results do not perfectly replicate the effects of the original text. The most likely reasons are differences in the data calculated by the MNN (Multimodal Neighborhood Network) algorithm or the use of specific input genes by the authors, which are not described in the original method.

```{r}
meta_oo <- readxl::read_excel(path = "1-s2.0-S0092867420300568-mmc2.xlsx", sheet = 2)
dim(meta_oo)
# Match cells and handle NA values
# 匹配细胞并处理 NA 值
matched_idx <- match(colnames(sc_oo), meta_oo$cell)
sc_oo$subtype <- meta_oo$cluster[matched_idx]

# Check for NA values
# 检查 NA 值
na_count <- sum(is.na(sc_oo$subtype))
if (na_count > 0) {
  cat("Warning:", na_count, "cells could not be matched in meta_oo. These will be excluded from subtype analysis.\n")
  # Optionally remove NA values or keep them
  # 可以选择移除 NA 值或保留它们
  # sc_oo <- sc_oo[, !is.na(sc_oo$subtype)]
}

table(sc_oo$subtype, sc_oo$seurat_clusters, useNA = "ifany")
```

用原文聚类获得的subtype画图

Plot the subtypes obtained from original text clustering

```{r}
#ggplot() +
  geom_point(mapping = aes(prres$x[,1],  prres$x[,2], color = sc_oo$subtype))

markers <- c("ZP1", "WEE2", "DNMT1", "ATP6", "FIGLA", "SOX17")

# Get expression data using appropriate API for Seurat version
# 使用适合 Seurat 版本的 API 获取表达数据
if (packageVersion("Seurat") >= "5.0.0") {
  expr_data <- LayerData(sc_oo, assay = "RNA", layer = "data")
} else {
  expr_data <- GetAssayData(sc_oo)
}

# Prepare plot data for original subtypes
# 为原始 subtype 准备绘图数据
plot_data_ori <- cbind(sc_oo@meta.data[,"subtype", drop = F],
                     PC1 = -pca.pv@cell.embeddings[,1],
                     expr_data[markers,] %>% t)
plot_data_ori <- plot_data_ori[!is.na(plot_data_ori$subtype), ]

# Create color palette for original subtypes
# 为原始 subtype 创建调色板
n_clusters_subtype <- length(unique(plot_data_ori$subtype))
colors_subtype <- c("darkmagenta", "steelblue", "chartreuse3", "red", "purple", "orange", "brown", "pink", "cyan", "magenta")
cluster_colors_subtype <- colors_subtype[1:n_clusters_subtype]
if (length(cluster_colors_subtype) < n_clusters_subtype) {
  cluster_colors_subtype <- c(cluster_colors_subtype, rainbow(n_clusters_subtype - length(cluster_colors_subtype)))
}

reshape2::melt(plot_data_ori,
  id.vars = c("subtype", "PC1")) %>%
  ggplot(mapping = aes(PC1, value)) +
  ylab("Relative expression") +
  geom_point(mapping = aes(color = subtype)) +
  geom_smooth() +
  scale_color_manual(values = cluster_colors_subtype,
                     na.value = "grey90",  # Color for NA values
                     drop = FALSE) +  # Keep all factor levels
  facet_wrap(~variable, scales = "free_y") +
  theme_classic() +
  theme(panel.border = element_rect(fill = NA),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
ggsave("PCA_B_ori_simplified_final.pdf", width = 7, height = 4)
```

## 主要改进 Key Improvements

1. **简化数据处理流程**: 移除了复杂的 mnnCorrect 步骤，直接使用标准 Seurat v5 流程，更接近 v4 版本的结果
2. **修正了 PCA 方差计算**: 使用正确的方差计算方法：`pc_var[1] / sum(pc_var) * 100`，而非错误的直接乘以 100
3. **改进了聚类命名逻辑**: 自动处理各种聚类命名格式，确保正确的 C1, C2, C3, C4 命名
4. **动态颜色调色板**: 自动生成能处理任意数量聚类的颜色方案，避免颜色不足错误
5. **强制4个聚类**: 如果自动聚类结果不是4个，使用 k-means 在 PCA 嵌入上强制分为4类，确保与原始论文一致
6. **保持 Seurat v5 兼容性**: 使用正确的 API (`LayerData`, `GetAssayData`)，同时简化了整体流程

## Session Info

```{r}
sessionInfo()
```